# Notice: Как завершаются программы на Go: return, panic и os.Exit

## Предисловие

(Слайд №1)

Привет всем заглянувшим.

В этом видео я разберу вопрос о том, как в Go обстоят дела в вопросе завершения программы.  

(Слайд №2)

Мы посмотрим на три варианта завершения программы:

1. Успешный или штатный — это возврат из main  
2. Аварийное завершение через panic  
3. Немедленное завершение через os.Exit

> Дополнительно
> 
> Конечно процесс может завершится и из за внешнего сигнала ОС или из за ошибки в рантайме или из за использования runtime.Goexit() но я не буду разбирать эти ситуации. 

Например, при работе над практической частью для прошлого ролика у меня появлялся вопрос, как я должен прервать выполнение программы в моем конкретном случае и как я должен решать этот вопрос в будущем при всех подобных ситуациях.  

В общем, для себя я сформулировал ответ на этот вопрос так:

(Слайд №3)

## Первый случай: return из main или дефолтное штатное завершение

Тут `main` либо просто по достижении своего конца завершает выполнение, либо явно через вызов return.  
По смыслу это именно успешное завершение программы.

Технически это выглядит так (Слайд №4):

- Запускаются все defer в main.
- ОС получает exit code 0.

И давайте глянем на пример в коде:
(demo/01/01.go)
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	defer fmt.Println("defer executed")

	fmt.Println("before return")

	if len(os.Args) > 1 && os.Args[1] == "return" {
		return
	}

	fmt.Println("after return")
}
```
Тут мы выполняем `Println("defer executed")` через `defer` и простой `Println("before return")`, далее выполняем проверку наличия аргумента "return". Если он есть, то выполнится return. Соответственно, в этом случае не отработает `Println("after return")`.  

Если мы вызовем на исполнение этот код сначала с аргументом "return", а потом без, и после каждого раза выполним в терминале `echo $?` (переменная `$?` содержит смысловой статус возврата последней выполненной программы, 0 - успешно, а 1 - ошибка), так вот мы увидим, что в обоих случаях код будет 0.  
То есть это говорит об успешном завершении предыдущей программы.

Давайте выполним код:
```bash
go run ./demo/01/01.go return
echo $?
go run ./demo/01/01.go
echo $?
```
И увидим, что все отработало в соответствиии с нашими ожиданиями. 
С этим всё, и идём дальше.

(Слайд №5)

## Второй случай: `panic()`

Это механизм инициации аварийной раскрутки стека.

Технически он выглядит так:

(Слайд №6)

- Вызывается panic(value)
- Вызываются все defer в текущей функции
- Если в каком-то defer вызывается recover(), то panic перехватывается
- Если panic не перехвачен → программа завершится с кодом 2
- Если panic перехвачен и дальнейшее выполнение не приводит к ошибке — программа завершиться штатно (обычно с кодом 0).

Но давайте посмотрим, как это будет выглядеть в коде:
(demo/02/02.go)
```go
package main

import "fmt"

func main() {
	defer fmt.Println("defer in main")
	b()
}

func a() {
	defer fmt.Println("defer in a")
	panic("something went wrong")
}

func b() {
	defer fmt.Println("defer in b")
	a()
}
```
Тут у нас есть две функции: `a` и `b`.  
В `main` через defer вызываем `Println("defer in main")` и вызываем `b`.

В теле функции `b` также через defer вызываем `Println("defer in b")` и вызываем `a`.

В теле `a` снова через defer вызываем `Println("defer in a")` и вызываем panic().

Это приводит к тому, что сначала отработает defer в `a`, потом в `b`, и последним — в main.  
И в самом конце отобразится информация об ошибке.

Давайте запустим:

```bash
go run demo/02/02.go
```

И увидим, что всё отработало, как мы и ожидали.

Последнее важное дополнение относительно применения panic() в отдельных goroutine.
В Go неперехваченный panic в любой goroutine завершает весь процесс,
а не только ту goroutine, где он произошёл.
На примере это выглядит так:
(demo/03/03.go)
```go
package main

import (
	"fmt"
	"time"
)

func main() {
	go func() {
		fmt.Println("goroutine started")
		panic("boom in goroutine")
	}()

	time.Sleep(time.Second)
	fmt.Println("main finished")
}
```
У нас есть запущенная `goroutine` и `Sleep` в `main`, 
а после `Println("main finished")`. 
Если запустить этот код, то:

- goroutine стартует
- внутри неё возникает panic
- panic не перехвачен
- runtime печатает stack trace
- процесс завершается
- строка "main finished" не будет выполнена

Давайте проверим:
```bash
go run ./demo/03/03.go
```
И увидим то что и ожидалось. 
```
goroutine started
panic: boom in goroutine
...
```

А вот если перехватить panic внутри goroutine, например как тут:
(demo/04/04.go)
```go
package main

import (
	"fmt"
	"time"
)

func main() {

	go func() {
		defer func() {
			if r := recover(); r != nil {
				fmt.Println("recovered:", r)
			}
		}()

		panic("boom")
	}()

	time.Sleep(time.Second)
	fmt.Println("main finished")
}
```
Тогда процесс продолжит работу.
Давайте проверим:
```bash
go run ./demo/04/04.go
```
И получим подтверждение.

Хорошо, с этим всё, и можем идти дальше.

(Слайд №7)

## Третий случай: `os.Exit(code)`

В этом случае немедленно завершается текущий процесс без выполнения отложенных вызовов (defer) и без раскрутки стека.  

Технически это выглядит так (Слайд №8):

- Вызывается os.Exit(code)
- Процесс немедленно завершается средствами ОС.
- Процесс завершает своё существование
- Стек НЕ раскручивается
- defer НЕ выполняются
- recover невозможен

Давайте посмотрим на пример и убедимся, что при os.Exit() действительно не отрабатывают `defer`:
(demo/05/05.go)
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	defer fmt.Println("defer executed") // не будет вызвана

	fmt.Println("before exit")
	os.Exit(127)

	fmt.Println("after exit") // не будет вызвана
}
```
Тут у нас просто вызывается через `defer` `Println("defer executed")`.
И os.Exit между двумя `Println`.
Так вот запустив этот код, мы увидим, что `Println("defer executed")` и также `Println("after exit")` не будет вызвана.

Код возврата, указанный в качестве аргумента для `os.Exit` (например, `0`, `1`, `2`, …), передаётся операционной системе.  
Давайте запустим и убедимся, что всё отработает так, как ожидается.
```bash
go run ./demo/05/05.go
```

Хорошо, с этим тоже всё, и двигаемся дальше.

(Слайд №9)

## Что такое `defer` и `recover` [кратко]

Далее для дополнительной ясности бегло пройдёмся по теме `defer` и `recover`.

(Слайд №10)

**`defer`** откладывает выполнение функции до выхода из текущей функции.  
Если в функции несколько defer, они выполняются по принципу LIFO (последний добавленный — выполняется первым).  
На примере это выглядит так:
(demo/06/06.go)
```go
package main

import "fmt"

func main() {
	defer fmt.Println("first")
	defer fmt.Println("second")
	defer fmt.Println("third")

	fmt.Println("main body")
}
```

Запустив этот код мы увидим:
```
main body
third
second
first
```

(Слайд №11)

А вот **`recover()`** может перехватить panic, но только если вызван внутри defer.  
Давайте посмотрим на следующий пример:
(demo/07/07.go)
```go
package main

import "fmt"

func main() {
	defer func() {
		if r := recover(); r != nil { 
			fmt.Println("recovered:", r)
		}
	}()

	panic("boom")
}
```
Смысл тут следующий: если был вызван panic(), то его сообщение словит и вернёт recover(), а если нет, то recover() вернёт nil.

Если panic перехвачен в defer внутри той же функции — выполнение продолжается после точки возврата этой функции.

Давайте посмотрим на это на примере:
(demo/08/08.go)
```go
package main

import "fmt"

func dangerous() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("recovered in dangerous:", r)
		}
	}()

	fmt.Println("before panic")
	panic("boom")
	fmt.Println("after panic") 
}

func main() {
	fmt.Println("calling dangerous")
	dangerous()
	fmt.Println("after dangerous")
}
```
Этот пример демонстрирует, что вызов `dangerous` приведёт к `panic`.  
Как результат, `Println("after panic")` не отработает, но `Println("after dangerous")` отработает, так как выполнение продолжается после точки возврата `dangerous`.

Давайте запустим пример и убедимся в этом.

```bash
go run ./demo/08/08.go
```
Как можно увидеть, "after panic" нет, а "after dangerous" есть.

А вот **если panic происходит выше по стеку, а recover ниже (то есть ближе к main) — нормальное выполнение продолжается после той функции, где был recover.**

На практике это выглядит так (demo/09/09.go):
```go
package main

import "fmt"

func dangerous() {
    fmt.Println("before panic!") // Отобразится первым
    panic("boom") // завершаю эту функцию и запускаю defer если таковые есть. 
	fmt.Println("after panic") 
}

func foo() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("recovered in foo:", r) // отобразится вторым recovered in foo: boom
        }
    }()

    dangerous() // frame #3
    fmt.Println("after dangerous") // НЕ ВЫПОЛНЯЕТСЯ!!! Так как тдет раскрутка стека и при возварет из dangerous сразу происхдит завершение foo и вызов ее defer.
}

func main() { // frame #1
    foo() // frame #2
    fmt.Println("after foo") // отобразится третим 
}

```
[Дописать описание кода на основе комментариев].
С этим блоком все, идем дальше.

Если у вас есть сложности с пониманием стека, по типу - что это вообще такое, где у него низ и верх и какие есть нюансы в контексте Go, то дайте знать в комментариях и я запишу об этом видео.  

(Слайд №12)

## Error

Первоначально я не планировал говорить об error, но позже понял, что без него картина будет неполной.

В Go существует тип error, однако его появление не приводит к остановке программы.  
В отличие от panic, ошибка — это обычное значение.
Она является частью нормального потока выполнения программы.
То есть (Слайд №13)
**В Go ошибки — это значения, а не исключения.**

error принято возвращать последним значением функции (Слайд №14):
```go
func readFile(path string) ([]byte, error)
```
Если функция не смогла выполнить свою задачу, она возвращает ненулевое значение error.  
При этом программа продолжает выполнение — вызывающий код сам решает, что делать дальше:

- обработать ошибку,
- залогировать,
- вернуть выше по стеку,
- или завершить программу.

Таким образом, error — это механизм передачи информации о проблеме,  
а не механизм аварийного завершения.

## Вывод

(Слайд №15)

А теперь давайте подведем итог.

1. `error` — это значение, сигнализирующее вызывающему коду о проблеме.  
Оно не завершает программу само по себе и является частью обычного потока выполнения.

2. `panic` применяется в тех случаях когда программисту нужно запустить раскрутку стека выполнения с запуском defer и возможностью восстановления.

3. `os.Exit` — механизм принудительного завершения процесса с заданным кодом возврата.  
Он завершает процесс немедленно: `defer` не выполняются, стек не раскручивается но есть возможность указывать необходимы коды возврата.

С этим всё, и переходим к финальной таблице.

## Итоговая таблица

Как дополнительный вывод, я сделал такую таблицу:

| Критерий                       | return из main        | panic                                                          | os.Exit                |
| ------------------------------ | --------------------- | -------------------------------------------------------------- | ---------------------- |
| Выполняются defer              | ✅                    | ✅ (при раскрутке стека текущей goroutine)                     | ❌                     |
| Возможен recover               | ❌                    | ✅ (если вызван в defer во время раскрутки)                    | ❌                     |
| Происходит раскрутка стека     | ❌                    | ✅ (до recover либо до завершения goroutine)                   | ❌                     |
| Печатается stack trace         | ❌                    | ✅ (если panic не перехвачен)                                  | ❌                     |
| Код завершения по умолчанию    | 0                     | обычно 2 (реализация runtime)                                  | задаётся явно          |
| Можно контролировать exit code | ❌ (только 0)         | ❌ (напрямую)                                                  | ✅                     |
| Семантика                      | Нормальное завершение | Инициирует аварийную раскрутку стека                           | Немедленное завершение |


Где мы увидим критерии, по которым можем определить, что нам подойдёт в конкретном случае.

На этом всё, не забывайте про лайк и подписку, если видео было вам полезным.  
Спасибо, что досмотрели, и всем пока!
 

