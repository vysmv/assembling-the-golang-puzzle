# Go по спецификации

Привет всем заглянувшим.
  
В этом видео я поделюсь с вами своими заметками по чтению спецификации.

После того как я познакомился с основными концепциями и понял, как работать с документацией, я немного задумался: куда дальше идти? Можно ворваться в практику — это почти всегда хороший вариант.  

Но меня заинтересовала спецификация. Мне захотелось взять паузу перед практическим опытом и вникнуть в язык. Сделать это один раз и попытаться понять и принять то, как устроен этот язык.

В общем, я запишу пару видео, чтобы вы оценили, нужно ли вам продолжение темы спецификации или нет.

Если да — ставьте лайк или пишите комментарий, чтобы я понимал уровень интереса к теме.

Ну хорошо, с этим всё, и давайте начнем.

## Введение / Introduction

А начнём мы с введения.  
Первое, что я вынес из спецификации, — это формальное определение языка от его разработчиков. Думаю, это стоит вынести отдельно, так как именно здесь зафиксировано то, чего от языка следует ожидать.

(Слайд №1)

Go — язык общего назначения, спроектированный с оглядкой на системное программирование. Он строго типизирован, использует сборщик мусора и явно поддерживает конкурентное программирование. Программы строятся из пакетов.

От себя я лишь расставлю акценты.

Это:

**Язык общего назначения**  
→ не DSL и не нишевый инструмент

**Системное программирование как контекст проектирования**  
→ не «низкоуровневый», а ориентированный на системы

**Строгая типизация + сборщик мусора**  
→ сознательное сочетание, а не компромисс

**Явная поддержка конкурентности**  
→ не как библиотека, а часть модели языка

Плюс:  
**пакеты как блоки функциональности.**

## Как читать спецификацию (Notation / Обозначение)

Далее, в разделе «Обозначение / Notation», нам говорят, что синтаксис языка описан при помощи EBNF.

**EBNF (Extended Backus–Naur Form)** — это:

- формальный способ описывать синтаксис языков;
- стандарт де-факто для спецификаций.

> **Важно:**
>
> EBNF — это не Go и не код вообще.  
> Это метаязык, который применили для описания синтаксиса Go.  
> Образно говоря, это язык, на котором написана инструкция к Go.


(Слайд №2)
Тут же нам приводят пример того, как описана спецификация:

- Syntax      = { Production } .
- Production  = production_name "=" [ Expression ] "." .
- Expression  = Term { "|" Term } .
- Term        = Factor { Factor } .
- Factor      = production_name | token [ "…" token ] | Group | Option | Repetition .
- Group       = "(" Expression ")" .
- Option      = "[" Expression "]" .
- Repetition  = "{" Expression "}" .

`Syntax = { Production } .` — это значит, что вся спецификация (Syntax) — это список повторяющихся правил (это Production). Фигурные скобки `{}` означают, что правил может быть сколько угодно (от 0 до *n*). Вариант «0 правил» технически возможен по правилам EBNF, но на практике это просто формальное описание того, что книга как бы состоит из глав это Production.

(Слайд №3)

На мой взгляд главное, что стоит вынести из этого описания — работу операторов, давайте на них посмотрим:

- A B   → A потом B
- A | B → либо A, либо B
- [ A ] → A может быть, а может не быть
- { A } → A может повторяться
- "if"  → буквально слово if
- A … B → выбор любого символа из диапазона от A до B. Например, decimal_digit = "0" … "9"
- ...   → просто обозначение "и тд".

Главный вывод для работы: (Слайд №4) когда мы увидим в спецификации строку вроде:
- SliceType = "[" "]" ElementType .

то мы понимаем её структуру:

1. Это `Production` (правило).
2. `SliceType` — это имя (нетерминал).
3. `"["` и `"]"` — это терминалы (пишем их в коде как есть).
4. `ElementType` — это ссылка на другое правило (нетерминал).
5. `.` в конце — это просто маркер конца правила.

Также при чтении спецификации важно понимать, является ли слово «конечным» или оно само состоит из других правил.  
Я сделал такой вывод:

(Слайд №5)
- **CamelCase** (например, `SliceType`) — это нетерминал (ссылка на другой Production).

- **lowercase** (например, `identifier`, ) — это терминал. 
Это имена правил для базовых элементов, таких как идентификаторы (identifier), целые числа (int_lit) или операторы.
Вы не пишете в коде слово «identifier». 
Вместо этого вы пишете любое имя (например, myVar).

- **"текст" в кавычках** — это терминал. 
То, что мы буквально печатаем в редакторе (например, `func`, `struct`, `{`).

> **Дополнительно**
>
> Почему «терминал»?  
> Это слово пришло из теории формальных языков и лингвистики.
>
> - **Терминал (terminal)** — это «конечная станция» или «тупик». Это то, что ты буквально пишешь в коде: буквы, цифры или знаки. Его нельзя разложить на что-то ещё. Например, `"if"` или `"+"` — это терминалы.
> - **Нетерминал (non-terminal)** — это ссылка, которую нужно «раскрыть» дальше. Она обычно написана в CamelCase. Например, `Type` — это нетерминал, потому что за ним стоит ещё одно правило, объясняющее, какие типы бывают.
>
> **Итог:** терминал — это «конечный символ», нетерминал — это «название правила».

(Слайд №6)

И в завершение — нюанс про маркеры версий (`[Go 1.xx]`). В спецификации часто встречаются пометки вроде `[Go 1.18]`, они указывают, что данная возможность (например, дженерики) появилась не сразу, а в конкретной версии языка.

В общем, я не хочу больше теоретизировать на эту тему, а просто посмотрим, как это проявится на практике чтения спецификации.

## Представление исходного кода (Source code representation)

Следующий раздел это "Представление исходного кода".

**Из него я вывел для себя следующие ключевые аспекты:**

### 1. Ключевой аспект: Единый стандарт: UTF-8

Весь исходный код Go — это текст в кодировке UTF-8.  
Это значит, что компилятор ожидает именно этот формат. Он позволяет использовать любые Unicode-символы, но с важной оговоркой: для идентификаторов (имён переменных) можно использовать не любой символ вообще (например, эмодзи нельзя), а только те, которые относятся к категориям Unicode **Letters** (буквы) и **Digits** (цифры).

### 2. Ключевой аспект: отсутствие канонизации

Go не канонизирует (то есть не исправляет и не объединяет) наш текст.

На практике это значит что: в Unicode один и тот же сложный символ (например, `ä` + `¨` символ диерезиса) можно записать двумя способами:

(Слайд №7)
- Как один готовый символ (одна «кодовая точка»). Это так называемые *precomposed* символы (предварительно составленные). Они представляют один code point для `ä` — `U+00E4`.
- Второй случай это когда символ представлен как комбинация базовой буквы и отдельного знака акцента (то есть как две «кодовые точки»). Такие символы называются *Combining sequences* (комбинированные). Представляют собой два кода — буква `a` (`U+0061`) + символ диерезиса `¨` (`U+0308`).

Если посмотреть на них как на символы, то они идентичны, но для системы это разные данные.

**Из этого разработчик может вынести для себя следующий смысл:** Если вы назовёте переменную первым способом, а попытаетесь обратиться к ней в коде, введя имя вторым способом, компилятор выдаст ошибку, так как для него это два разных идентификатора.

На примере это будет выглядеть так:

```go
package main

import "fmt"

func main() {
	s1 := "\u00e4"   // "ä" as a single code point (U+00E4)
	s2 := "a\u0308"  // "ä" as a combination of "a" (before the backslash) (U+0061) + "¨" (U+0308)


	s3 := "ä"
	s4 := "ä"

	s5 := "ä"
	s6 := "ä"
	
	fmt.Println(s1 == s2) // false
	fmt.Println(len(s1))  // 2 bytes in UTF-8 (single code point)
	fmt.Println(len(s2))  // 3 bytes in UTF-8 (two code points)

	fmt.Println(s1)  // ä
	fmt.Println(s2)  // ä

	if s3 == s4 {
		fmt.Println("s3 and s4 are equal")
	} else {
		fmt.Println("s3 and s4 are not equal")
	}

	if s5 == s6 {
		fmt.Println("s5 and s6 are equal")
	} else {
		fmt.Println("s5 and s6 are not equal")
	}

	/*If such situations arise, it is worth comparing the sizes of the strings in bytes.*/
	if len(s3) != len(s4) {
		fmt.Println("the number of bytes is different")
	}
}
```
У нас есть код, в котором мы объявляем переменные `s1` и `s2` как строки, заданные через кодовые точки.

Где `s1` — это символ `ä`, представленный как одна кодовая точка (`U+00E4`), то есть символ `a` с диерезисом в предварительно составленном виде.

А в `s2` символ `ä` задан как комбинация: базовая буква `a` (код `U+0061`) плюс символ диерезиса `¨` (dieresis) с кодом `U+0308`. 

Далее мы видим инициализацию `s3` и `s4`.  
Мы инициализируем их визуально одинаковыми строками.

То же самое делаем для переменных `s5` и `s6`.

После этого мы выводим:
- результат сравнения `s1` и `s2`,
- длину строк `s1` и `s2` в байтах,
- а затем просто печатаем значения `s1` и `s2` в терминал.

Затем мы выполняем сравнение `s3` и `s4`, а также `s5` и `s6`.  
И ещё раз сравниваем `s1` и `s2` по количеству байт.

Возникает вопрос, в чём смысл этого странного примера?

А смысл в том, что если мы запустим код, то увидим следующее:

- сравнение `s1 и s2` — `false`
- `s1` занимает 2 байта
- `s2` занимает 3 байта
- внешне `s1` и `s2` выглядят одинаково

Далее мы видим, что `s3` и `s4` не равны,  
а `s5` и `s6` — равны.

Также мы видим, что количество байт у `s1` и `s2` различается.

То есть мы можем столкнуться с ситуацией, когда строки визуально одинаковы, но не равны, и при этом в другом месте увидеть, что строки равны.

Если вдруг возникает такая ситуация, то выяснить причину можно через сравнение строк по байтам.  
Для Go символы — это именно кодовые точки Unicode, и не имеет значения, как символы выглядят при выводе. Ответственность за корректность в этом вопросе лежит на программисте, а не на компиляторе.


### 3. Ключевой аспект: Правила формирования идентификаторов  
(например таких как, имена переменных или функций)

Тут есть несколько моментов которые стоит запомнить:
(Слайд №8)
- **Регистрозависимость:** заглавные и строчные буквы — это всегда разные символы (например, `A ≠ a`).
- **Специальная роль подчёркивания:** символ `_` в Go официально считается строчной буквой. Это позволяет использовать его в начале и внутри имён.
- **Цифры:** используются только стандартные арабские цифры (`0–9`).

**Итог раздела:** Go даёт огромную свободу в использовании языков, но перекладывает ответственность за чистоту и единообразие текста на разработчика.  

На этом я завершу первый фрагмент о спецификации, а в качестве дополнения поделюсь тем, как я решал возникшую передо мной практическую задачу.

Это **не связанная напрямую с темой спецификации** практическая задача — просто дополнительный контент.

Возможно, чтобы немного разбавлять чтение спецификации, я время от времени буду добавлять небольшую практику.

Все примеры и тезисы я демонстрировал в консольном слайдере.  
Именно это небольшое приложение мы сейчас и разберём.


## практика

### ТЗ.
[
	Удалить.
	Нашей целью будет, написать консольное TUI-приложение «Слайдер», которое отображает текстовые «слайды» (из директории, переданной ему в качестве первого аргумента) и позволяет листать их командами.
	Детальное описание ТЗ вы можете найти в текстовой версии видео. 
	Ссылка на нее будет в закрепленном комментарии. 
	Думаю, что ТЗ всегда удобнее читать, а не воспринимать на слух.
	По этому не буду его озвучивать.
	Как вариант, вы можете сейчас поставить видео на паузу и ознакомиться с ТЗ, а потом попробовать выполнить все это самостоятельно, после чего вернуться к моему решению. 
	Понимать чей-то взгляд всегда легче после того как вы сами пытались это сделать.
]

#### Цель

Написать консольное TUI-приложение «Слайдер», которое отображает текстовые «слайды» (из директории, переданной ему в качестве первого аргумента) и позволяет листать их командами.

#### Источник данных

Программа читает слайды из директории, указанной в аргументе.

Слайды — обычные текстовые файлы без расширений с именами вида: 1…n.

#### Экран и отображение

При запуске программа отображает первый слайд и ждёт ввода пользователя.  
Отображая под рамкой

```bash
[1...n]=open a slide by its number / [n]=next / [p]=prev [q]=quit >
```

В правом верхнем углу внутри рамки отображается индикатор: `X/Y`, где:

- `X` — номер текущего слайда (начиная с 1),
- `Y` — общее количество слайдов.

Внутри рамки, начиная через три строки от верхней границы, печатается содержимое текущего слайда.

Выравнивание по левому краю.

#### Управление

- `n` → следующий слайд.
- `p` → предыдущий слайд.
- `q` → выход.
- Число `k` → открыть слайд номер `k` (нумерация с 1).

Если `k` вне диапазона `1..Y`, вывести сообщение:
slide {k} not found.
То есть также очистить экран и перерисовать рамку, но с текстом `slide {k} not found`,  
и продолжить ожидание ввода.

#### Навигация (wrap-around)

- При `n` на последнем слайде → переход на первый.
- При `p` на первом слайде → переход на последний.
- Листание бесконечно в обе стороны.

#### Параметры отображения

Размер рамки: берём реальный размер терминала.

На Go это обычно `golang.org/x/term` (не stdlib, но официальный репозиторий).

Используем реальный размер, а если не получилось — fallback `80×24`.

Рамка «по краям экрана»: используем символы типа `─`.

Формат слайдов: текст как есть, `\n` сохраняем.

Не интерактивный raw-mode.

Ввод читаем строкой через Enter (`bufio.Reader`).

Как результат — бинарник, способный принять путь к коллекции текстовых файлов и отображающий их содержимое.
++++++++++++++++++++++++++++++++++++++++++++++++++

### Реализация 

Хорошо, перейдем к реализации.

Я решил разделить программу на четыре слоя:

1. Domain — логика навигации

2. Store — источник данных

3. UI — ввод и отображение

4. App — оркестратор (application layer)

И организовать проект следующим образом: 

(Слайд №9)

```bash
slider/
  go.mod
  cmd/slider/main.go
  internal/app/app.go
  internal/domain/state.go
  internal/store/store.go
  internal/store/dir.go
  internal/ui/term/term.go
  internal/ui/term/render.go
```

Давайте бегло посмотрим на код и логику программы.
Начнём с файла main.go.

#### main.go и слой store

main в нашем случае — это точка входа и место принятия решения о завершении программы.

Первым делом выполняется проверка наличия аргумента командной строки —
пути к директории со слайдами. Указать путь к хранилищу слайдов обязательно.

Далее вызывается `NewDirStore` из пакета `store`. 

Внутри него выполняется проверка корректности стартовых условий:
существует ли директория, содержит ли она файлы 1..n, нет ли пропусков и т.д.
По текстам ошибок достаточно легко понять, какие именно проверки там выполняются.

В случае успеха `NewDirStore` возвращает указатель на `DirStore` и `nil`.

`DirStore` — это структура с полями dir и total
и двумя методами:

- Total() — возвращает общее количество слайдов
- Content(k) — возвращает содержимое слайда по ключу

Таким образом, пакет store представляет собой слой доступа к данным —
интерфейс взаимодействия с файловой системой и её содержимым.

Отдельно стоит обратить внимание на файл store.go,
в котором описан интерфейс — контракт хранилища.

Важно, что слой `Store` не знает:

- что такое n / p / q
- что такое рамка
- что такое wrap-around
- что пользователь вводит строку и нажимает Enter

Прежде чем продолжить разбор потока управления, посмотрим на остальные пакеты,
чтобы целиком увидеть зоны разделения ответственности.

#### Domain / State

`Domain` отвечает за логику навигации и изменения состояния.

Здесь описывается текущее состояние слайдера —
какой слайд сейчас активен и как это состояние может изменяться.

Это структура состояния, функция его создания и три метода:

- Next
- Prev
- Open

Именно их вызовы изменяют текущее состояние.

При этом `Domain` не знает:

- где физически лежат слайды
- как происходит отрисовка
- откуда приходит команда пользователя

Это чистая бизнес-логика. ???

#### UI / term

Далее идёт `UI` — слой представления через терминал.

Так как `UI` является абстракцией, создана поддиректория term
как его конкретная реализация.

Пакет `ui/term` состоит из двух файлов, разделённых по зонам ответственности.

Первая зона — `term.go`

Этот файл отвечает за взаимодействие с потоками ввода и вывода.
Иначе говоря: «читаю и пишу, но не решаю что».

Здесь определены только два метода:

`ReadLine` — читает пользовательский ввод и возвращает строку

`Print` — отправляет сформированную строку в выходной поток

Вторая зона — `render.go`

Этот файл отвечает за формирование визуальной модели слайда
и за его отрисовку в терминале.

Рендеринг выполняется построчно через вызовы метода `Print`.

Важно, что render.go отвечает только за внешний вид,
но не за смысл отображаемых данных.

#### App — оркестратор

`App` — это application layer, или “оркестратор”.

В его структуре есть поля:

- store store.SlideStore — источник данных (через интерфейс)
- ui *term.UI — пользовательский интерфейс
- state domain.State — текущее состояние
- msg string — временное сообщение (например, об ошибке)

Также есть функция `New` для создания экземпляра `App`
и метод `Run`.

Именно в `Run` крутится основной цикл приложения,
который связывает между собой все слои.

Если теперь вернуться в `main.go` и продолжить движение по потоку выполнения,  
мы увидим, что после `NewDirStore` у нас есть ещё вызов `NewUI`, а затем значения, возвращаемые этими функциями, мы передаём в `app.New`, которая возвращает `*app.App` в переменную `a`.

После этого приложение запускается вызовом `a.Run()`.

Как мы уже выяснили, именно там сосредоточена вся координация между слоями.

Далее описывать код построчно я не буду.
Кому интересно посмотреть детали, может посмотреть его на `GitHub` по ссылке в закреплённом комментарии.

На этом всё. Напомню, что не забывайте подписываться, если вам хотелось бы ещё выпусков с разбором спецификации.
Подписка в ТГ и звёздочки на GitHub — тоже дополнительная мотивация.
Спасибо, что досмотрели, и пока!









































@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Давайте бегло посмотрим на код и логику программы.
Начнём с файла main.go.

main в нашем случае — точка входа и место принятия решения о завершении програмы.

Первым делом у нас идет проверка на наличие аргумента при вызове.

Это указание пути к директории со слайдами. Указать путь к хранилищу слайдов - обязательно.

Далее мы вызываем `NewDirStore` из пакета `store`.

В теле которой вызывается функция `check`. Для проверки корректности стартовых условий.
По тексту сообщений об ошибках легко понять, что именно мы тут проверяем. 

В общем `NewDirStore` возвращает указатель типа `DirStore` и nil в случае успеха.

Значение типа DirStore - это структура с полями `dir` и `total`.
И двумя методами: `Total` (общее кол-во слайдов) и `Content` (содержание слайда по его номеру). 

В данном случае пакет store это програмный слой, как интерфейс взаимодействия с директорией и ее файлами.

Тут еще только обращу внимание. что пакет также содержит файл `store.go` в котором описан один контракт. 

То есть Store не знает:

- что такое n/p/q
- что такое “рамка”
- что такое “wrap-around”
- что пользователь вводит строку и нажимает Enter

Давайте, перед тем как продолжим разбор потока управления посмотрим на остальные пакеты, чтобы понять все имеющиеся зоны разделения ответственности. 

+++++++++++++++

Domain / State — логика навигации. Логика изменения состояния. То есть текущее состояние слайдера, определяющее какой слайд должен отображаться.

Это также структура, функция создания экземпляра и три метода Next, Prev, Open.
Вызов которых и меняет текущее состояние.

Domain не знает:

- где лежат слайды 
- как рисовать в терминале 
- откуда приходит команда 

+++++++++++++++ 

Далее идёт UI — слой представления через терминал. 
Так как UI является абстракцией, создана поддиректория term как его конкретная реализация. 

Пакет ui/term состоит из двух файлов, разделённых по зонам ответственности. 

Первая зона — term.go. 
Он отвечает за взаимодействие с потоками ввода и вывода. 
Иначе говоря: «читаю и пишу, но не решаю что». 
Здесь определены только два метода:

ReadLine — читает пользовательский ввод и возвращает строку

Print — отправляет сформированную строку в выходной поток

Вторая зона — render.go.
Он отвечает за формирование визуальной модели слайда и за его отрисовку в терминале.
Рендеринг выполняется построчно через вызовы метода Print. 

++++++++++++++++

App — “оркестратор” (Application layer)

В его структуре есть поля:
- store store.SlideStore (тут в качестве типа выступает интерфейс)
- ui    *term.UI
- state domain.State
- msg   string  

Есть функция `New` для создания значения типа `App`.
И есть метод `Run`.

Именно тут и крутится бесконечный цикл использующий возможнсти всех слоев. 

То есть если мы сейчас вернемся в `main.go` и проследуем по потоку исполнения с того где остановились, то увидим что мы создаем *app.App используя метод `app.New`.

Передавая ему аргументами `st store.SlideStore, ui *term.UI`

И запускаем приложение через вызов `a.Run()`.

Где как мы уже выяснили сосредоточена работа со всеми слоями. 

Далее описывать код построчно я не буду. 
Кому интересно может посмотреть его на GitHub по ссылке в закрепленном комментарии. 

На этом все. Напомню, что не забывайте подписываться, если вам хотелось бы еще выпусков с разбором спецификации. Подписка в ТГ и звездочки на GitHub тоже дополнительная мотивация. 
Спасибо, что досмотрели и Пока!





















## Lexical elements — Лексические элементы

### Comments 

Первым пунктом нам сообщают, что в Go существует две формы комментариев:
- Строчные (Line comments): начинаются с последовательности // и заканчиваются в конце строки.
- Общие (General comments): начинаются с /* и заканчиваются первым встреченным */

Это распространенная практика.
Единственный нюанс который стоит положить в заметку это то, что в Go автоматически добавляет `;` после литералов или имен переменных, если за ними следует «новая строка».

Разница между комментариями в том, что `//` всегда считается новой строкой, а `/* */` (без переносов внутри) считается пробелом.

Это не то чтобы ключевой момент но например в этих двух случаях, есть разница
```go
// Скомпилируется: /* */ работает как пробел
f := complex(1.0 /* real */, 2.0) 

// ОШИБКА: // сработает как newline и вставит ";" после 1.0
// f := complex(1.0 // real , 2.0) 
``` 

### Tokens 

Далее спецификация сообщает нам, что Токены (лексемы) — это «словарь» языка Go.

Они делятся на 4 класса:
- Идентификаторы (имена переменных, функций и т.д.).
- Ключевые слова (зарезервированные слова вроде func или package).
- Операторы и пунктуация (знаки вроде +, :=, {).
- Литералы (фиксированные значения: числа, строки).

###  Semicolons 

Тут важно понять не «как именно вставляются ;», а где нельзя переносить строку. Всё остальное — детали реализации лексера.
В Go перенос строки это потенциальная `;`, если он идет после:
• Идентификатор (имя переменной, функции и т.д.).
• Литерал (число, строка, руна).
• Ключевые слова: break, continue, fallthrough или return.
• Операторы и пунктуация: ++, --, ), ] или }.

Например если сделать перенос перед else:
```go
if x > 0 {
    foo()
}
else {
    bar()
}
```
То для компилятора это будет:
```go
if x > 0 {
    foo()
};
else { ... }
```

###  Identifiers 

Тут можно коротко отметить идентификатор — это имя, которым мы обозначаем сущности программы
(переменные, типы и т.п.).

идентификатор:

- состоит из букв и цифр
- обязан начинаться с буквы

###  Keywords 

Основные выводы - Ключевые слова нельзя использовать как идентификаторы. 
Нельзя написать:
```go
var func int
type for struct {}
```
Вот полный список ключевых слов:
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var

Вот полный список опрераторов и пунктуации:
+    &     +=    &=     &&    ==    !=    (    )
-    |     -=    |=     ||    <     <=    [    ]
*    ^     *=    ^=     <-    >     >=    {    }
/    <<    /=    <<=    ++    =     :=    ,    ;
%    >>    %=    >>=    --    !     ...   .    :
     &^          &^=          ~

### Integer literals/Целочисленные литералы

Смысловое резюме
В Go literal — это синтаксическая форма записи константного значения.
Спецификация языка выделяет ровно пять категорий литералов:

- Integer literals
- Floating-point literals
- Imaginary literals
- Rune literals
- String literals

Это именно классификация синтаксиса, а не типов.

Дам немного больше контекста, чтобы убрать потенциальную путаницу.
В Go существует пять синтаксических форм литералов, которыми записываются константные значения.

Таким образом, программист располагает ограниченным набором форм записи значений. Эти значения могут присваиваться переменным или константам.
Отдельно от литералов в языке существует множество типов. Через выбор типа программист задаёт контекст использования значения — то есть определяет, как компилятор будет с ним работать.

В частности, тип определяет представление значения в памяти (в случае переменных), а также набор допустимых операций и правил преобразования.

Целочисленный литерал — это последовательность цифр, представляющая константу. 
Go поддерживает четыре системы счисления, которые определяются префиксом:

- Десятичная: без префикса (например, 42). Число 0 само по себе — это десятичный ноль.
- Двоичная: 0b или 0B.
- Восьмеричная: 0o, 0O или просто 0.
- Шестнадцатеричная: 0x или 0X. Буквы a-f (или A-F) обозначают значения 10–15.

Для удобства чтения можно использовать символ подчеркивания _ между цифрами или после префикса (например, 1_000 или 0x_ff), это не меняет значение числа.

И давайте посмотрим как читать синтаксические правила EBNF.

//Целое число может быть либо десятичным, либо двоичным и т.д
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .


decimal_lit    = "0" | ( "1" … "9" ) [ [ "_" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .

decimal_digits = decimal_digit { [ "_" ] decimal_digit } .
binary_digits  = binary_digit { [ "_" ] binary_digit } .
octal_digits   = octal_digit { [ "_" ] octal_digit } .
hex_digits     = hex_digit { [ "_" ] hex_digit } .