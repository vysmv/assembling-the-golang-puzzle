# Go по спецификации

## Предисловие

Привет всем заглянувшим.

В этом видео я поделюсь с вами своими заметками по чтению спецификации.

После того как я познакомился с основными концепциями `Go` и понял, как работать с документацией, у меня возник вопрос: а куда дальше идти?  
Можно, конечно, ворваться в практику — это почти всегда хороший вариант.

Но меня заинтересовала спецификация.  
Мне захотелось посмотреть на устройство языка, описанное разработчиками.  
Не знаю, насколько увлекательным будет это чтение,  
но как минимум понять, как ей пользоваться, — точно будет полезным или даже необходимым опытом.

В общем, я запишу одно-два видео, чтобы и я, и вы оценили, нужно ли продолжение этой темы или нет.

Если интересно, дайте знать об этом в комментариях.

Ну хорошо, с этим всё — давайте начнём.

## Введение / Introduction

А начнём мы с введения.  
Первое, что я вынес из спецификации, — это формальное определение языка. Думаю, это стоит вынести отдельно, потому что именно здесь зафиксировано то, чего от языка следует ожидать.

(Слайд №1)

Go — язык общего назначения, ориентированный на системное программирование. Он строго типизирован, использует сборщик мусора и явно поддерживает конкурентное программирование. Программы строятся из пакетов.

## Как читать спецификацию (Notation / Обозначение)

Далее, в разделе «Notation», нам говорят, что синтаксис языка описан при помощи EBNF.

**EBNF (Extended Backus–Naur Form)** — это формальный способ описывать синтаксис языков.

> **Важно:**
>
> EBNF — это не Go и не код вообще.  
> Это метаязык, который применили для описания синтаксиса Go.

(Слайд №2)

Тут же нам приводят пример того, как описана спецификация:

- Syntax      = { Production } .
- Production  = production_name "=" [ Expression ] "." .
- Expression  = Term { "|" Term } .
- Term        = Factor { Factor } .
- Factor      = production_name | token [ "…" token ] | Group | Option | Repetition .
- Group       = "(" Expression ")" .
- Option      = "[" Expression "]" .
- Repetition  = "{" Expression "}" .

Из этого примера я вынес то, что вся спецификация — это `Syntax`, то есть список правил (которые именуются `Production`).

А также логику работы операторов (Слайд №3):

- A B   → A, потом B
- A | B → либо A, либо B
- [ A ] → A может быть, а может не быть
- { A } → A может повторяться
- "if"  → буквально слово `if`
- A … B → выбор любого символа из диапазона от A до B. Например, `decimal_digit = "0" … "9"`
- ...   → просто обозначение «и т. д.»

Но тут стоит упомянуть и принцип разделения на терминалы и нетерминалы (Слайд №4):

- Если мы видим **CamelCase** (например, `SliceType`), — это нетерминал (ссылка на другой `Production`).

- Если видим **lowercase** (например, `identifier`), — это терминал. То есть это уже не поддающийся разложению элемент.

- Далее, **"текст" в двойных кавычках** — это тоже терминал.  
  Такой терминал мы буквально пишем в коде (например, `func`, `struct`, `{`).

То есть когда мы на практике увидим в спецификации строку вроде этой (Слайд №5):

```
SliceType = "[" "]" ElementType .
```

Мы сможем понять её структуру:

1. (Слайд №6) Всё это вместе является правилом или `Production`.
2. (Слайд №7) `SliceType` — это имя правила (или, иначе говоря, нетерминал).
3. (Слайд №8) `"["` и `"]"` — это терминалы (то есть пишем их в коде как есть).
4. (Слайд №9) `ElementType` — это ссылка на другое правило (нетерминал).
5. (Слайд №10) `.` в конце — это просто маркер конца правила.

И в завершение — нюанс про маркеры версий (Слайд №11).  
В спецификации часто встречаются пометки вроде `[Go 1.18]`: они указывают, что данная возможность (например, дженерики) появилась не сразу, а в конкретной версии языка.

В общем, я думаю, достаточно теории по этому разделу, а дальше просто посмотрим, как это проявится на практике чтения спецификации.

## Представление исходного кода (Source code representation)

Следующий раздел — это «Представление исходного кода».

**Из него я вывел для себя следующие ключевые аспекты:**

### 1. Ключевой аспект: единый стандарт — UTF-8

Весь исходный код Go — это текст в кодировке UTF-8.  
Это значит, что компилятор ожидает именно этот формат.  
Он позволяет использовать любые Unicode-символы, но с важной оговоркой: для идентификаторов можно использовать не любой символ вообще (например, эмодзи нельзя), а только те, которые относятся к категориям Unicode **Letters** (буквы) и **Digits** (цифры).

### 2. Ключевой аспект: отсутствие канонизации

Go не канонизирует (то есть не исправляет) наш текст.

На практике это значит, что в Unicode один и тот же сложный символ (например, `a` + `¨` — символ диерезиса) можно записать двумя способами:

(Слайд №12)

- Как один готовый символ (одна «кодовая точка»). Это так называемые *precomposed* символы (предварительно составленные). Они представляют один code point для `a` + `¨` (символ диерезиса) — `U+00E4` (`ä`).
- Второй случай — это когда символ представлен как комбинация базовой буквы и отдельного знака акцента (то есть как две «кодовые точки»). Такие символы называются *combining sequences* (комбинированные). Они представляют собой два кода: буква `a` (`U+0061`) + символ диерезиса `¨` (`U+0308`).

Если посмотреть на них как на символы, то они идентичны, но для системы это разные данные.

**Из этого разработчик может вынести следующий смысл:** если строка или идентификатор будут содержать предварительно составленный символ, а затем при сравнении или обращении по идентификатору будет использован комбинированный символ, то компилятор выдаст ошибку, так как для него это два разных символа.

На примере это будет выглядеть так:

```go
package main

import "fmt"

func main() {
	s1 := "\u00e4"   
	s2 := "a\u0308"


	s3 := "ä"
	s4 := "ä"

	s5 := "ä"
	s6 := "ä"
	
	fmt.Println(s1 == s2) 
	fmt.Println(len(s1))  
	fmt.Println(len(s2))  

	fmt.Println(s1) 
	fmt.Println(s2) 

	if s3 == s4 {
		fmt.Println("s3 and s4 are equal")
	} else {
		fmt.Println("s3 and s4 are not equal")
	}

	if s5 == s6 {
		fmt.Println("s5 and s6 are equal")
	} else {
		fmt.Println("s5 and s6 are not equal")
	}

	if len(s1) != len(s2) {
		fmt.Println("the number of bytes is different")
	}
}
```
У нас есть код, в котором мы объявляем переменные `s1` и `s2` как строки, заданные через кодовые точки.

Где `s1` — это символ `a` с диерезисом, представленный как одна кодовая точка (`U+00E4`).

А в `s2` символ задан как комбинация: базовая буква `a` (код `U+0061`) плюс символ диерезиса `¨` (*dieresis*) с кодом `U+0308`.

Далее мы видим инициализацию `s3` и `s4`.  
Мы инициализируем их визуально одинаковыми строками.

То же самое делаем для переменных `s5` и `s6`.

После этого мы выводим:
- результат сравнения `s1` и `s2`;
- длину строк `s1` и `s2` в байтах;
- а затем просто печатаем значения `s1` и `s2` в терминал.

Затем мы выполняем сравнение `s3` и `s4`, а также `s5` и `s6`.  
И ещё раз сравниваем `s1` и `s2` по количеству байт.

Возникает вопрос: в чём смысл этого странного примера?

А смысл в том, что если мы запустим код, то увидим следующее:

- сравнение `s1` и `s2` — `false`;
- `s1` занимает 2 байта;
- `s2` занимает 3 байта;
- внешне `s1` и `s2` выглядят одинаково.

Далее мы видим, что `s3` и `s4` не равны,  
а `s5` и `s6` — равны.

Также мы видим, что количество байт у `s1` и `s2` различается.

То есть мы можем столкнуться с ситуацией, когда строки визуально одинаковы, но не равны, и при этом в другом месте увидеть, что эти строки равны.

Если вдруг возникает такая ситуация, то выяснить причину можно через сравнение строк по количеству байт.  
Для Go символы — это именно кодовые точки Unicode, и не имеет значения, как символы выглядят при выводе. Ответственность за корректность в этом вопросе лежит на программисте, а не на компиляторе.

### 3. Ключевой аспект: правила формирования идентификаторов

Тут есть несколько моментов, которые стоит запомнить:

(Слайд №13)

- **Регистрозависимость:** заглавные и строчные буквы — это всегда разные символы (например, `A ≠ a`).
- **Специальная роль подчёркивания:** символ `_` в Go официально считается строчной буквой. Это позволяет использовать его в начале и внутри имён идентификаторов.
- **Цифры:** используются только стандартные арабские цифры (`0–9`).

**Подведём итог раздела:** Go даёт огромную свободу в использовании языков, но перекладывает ответственность за чистоту и единообразие текста на разработчика.

На этом я завершу первый фрагмент о спецификации, а в качестве дополнения поделюсь тем, как я решал возникшую передо мной практическую задачу.

Эта задача **не связанная напрямую с темой спецификации**, а — просто дополнительный контент.

Возможно, чтобы немного разбавлять чтение спецификации, я время от времени буду добавлять небольшую практику.

Все примеры и тезисы я демонстрировал в консольном слайдере.  
Именно это небольшое приложение мы сейчас и разберём.

## Практика

### ТЗ.

#### Цель

Написать консольное TUI-приложение «Слайдер», которое отображает текстовые «слайды» (из директории, переданной ему в качестве первого аргумента) и позволяет листать их командами.

#### Источник данных

Программа читает слайды из директории, указанной в аргументе.

Слайды — обычные текстовые файлы без расширений с именами вида 1…n.

#### Экран и отображение

При запуске программа отображает первый слайд и ждёт ввода пользователя,  
отображая подсказку под рамкой.

```bash
[1...n]=open a slide by its number / [n]=next / [p]=prev [q]=quit >
```

В правом верхнем углу внутри рамки отображается индикатор: `X/Y`, где:

- `X` — номер текущего слайда (начиная с 1),
- `Y` — общее количество слайдов.

Внутри рамки, начиная через три строки от верхней границы, печатается содержимое текущего слайда.

Выравнивание — по левому краю.

#### Управление

- `n` → следующий слайд.
- `p` → предыдущий слайд.
- `q` → выход.
- Число `k` → открыть слайд номер `k` (нумерация с 1).

Если `k` вне диапазона `1..Y`, вывести сообщение:  
`slide {k} not found.`

То есть также очистить экран и перерисовать рамку, но с текстом `slide {k} not found`,  
и продолжить ожидание ввода.

#### Навигация (wrap-around)

- При `n` на последнем слайде → переход на первый.
- При `p` на первом слайде → переход на последний.
- Листание бесконечно в обе стороны.

#### Параметры отображения

Размер рамки: берём реальный размер терминала.

На Go это обычно `golang.org/x/term` (не stdlib, но официальный репозиторий).

Используем реальный размер, а если не получилось — fallback `80×24`.

Рамка «по краям экрана»: используем символы типа `─`.

Формат слайдов: текст как есть, `\n` сохраняем.

Не интерактивный raw-mode.

Ввод читаем строкой через Enter (`bufio.Reader`).

Как результат — бинарник, способный принять путь к коллекции текстовых файлов и отображающий их содержимое.

### Реализация 

Ну хорошо, давайте перейдём к реализации.

Я решил разделить программу на четыре слоя:

(Слайд №14)

1. Domain — логика навигации.
2. Store — источник данных.
3. UI — ввод и отображение.
4. App — оркестратор (application layer).

И организовать проект следующим образом:

(Слайд №15)

```bash
slider/
  go.mod
  cmd/slider/main.go
  internal/app/app.go
  internal/domain/state.go
  internal/store/store.go
  internal/store/dir.go
  internal/ui/term/term.go
  internal/ui/term/render.go
```

Но давайте бегло посмотрим на код и логику программы.  
Начнём с файла main.go.

#### main.go и слой store

`main` в нашем случае — это точка входа и место принятия решения о завершении программы.

Первым делом здесь выполняется проверка наличия аргумента командной строки, то есть
пути к директории со слайдами.  
Указать путь к хранилищу слайдов обязательно.

Далее вызывается `NewDirStore` из пакета `store`.

Внутри него выполняется проверка корректности стартовых условий:
существует ли директория, содержит ли она файлы от 1..n, нет ли пропусков и т. д.  
По текстам ошибок достаточно легко понять, какие именно проверки там выполняются.

В случае успеха `NewDirStore` возвращает указатель на `DirStore` и `nil`.

`DirStore` — это структура с полями `dir` и `total`
и двумя методами:

- `Total()` — возвращает общее количество слайдов;
- `Content(k)` — возвращает содержимое слайда по ключу.

Таким образом, пакет `store` представляет собой слой доступа к данным —
интерфейс взаимодействия с файловой системой и её содержимым.

Отдельно стоит обратить внимание на файл `store.go`,
в котором описан интерфейс (контракт) хранилища.

Важно, что слой `Store` не знает ничего за рамками своей зоны ответственности.

Прежде чем продолжить разбор потока управления, посмотрим на остальные пакеты,
чтобы целиком увидеть все зоны разделения ответственности.

#### Domain / State

`Domain` отвечает за логику навигации и изменения состояния.

Здесь описывается текущее состояние слайдера —
какой слайд сейчас активен и как это может изменяться.

Всё это реализовано как структура, функция для создания значения и три метода:

- `Next`
- `Prev`
- `Open`

Эти методы дают возможность менять текущее состояние.

При этом `Domain` также ничего не знает за рамками своей зоны ответственности.  

#### UI / term

Далее идёт `UI` — слой представления через терминал.

Так как `UI` является абстракцией, создана поддиректория `term`
как его конкретная реализация.

Пакет `ui/term` состоит из двух файлов, также разделённых по зонам ответственности.

Первая зона — это файл `term.go`.

Этот файл отвечает за взаимодействие с потоками ввода и вывода.  
Иначе говоря: «читаю и пишу, но не решаю, что».

Здесь определены только два метода:

- `ReadLine` — читает пользовательский ввод и возвращает строку;
- `Print` — отправляет сформированную строку в выходной поток.

Вторая зона — это файл `render.go`.

Этот файл отвечает за формирование визуальной модели слайда
и за отрисовку в терминале.

Рендеринг выполняется построчно через вызовы метода `Print`.

#### App — оркестратор

Следующим идет слой приложения `App`.

В его структуре есть следующие поля:

- `store store.SlideStore` — источник данных (через интерфейс);
- `ui *term.UI` — пользовательский интерфейс;
- `state domain.State` — текущее состояние;
- `msg string` — временное сообщение (например, об ошибке).

Также есть функция `New` для создания экземпляра `App`
и метод `Run`.

Именно в `Run` крутится основной цикл приложения,
который связывает между собой все слои.

Если теперь вернуться в `main.go` и продолжить движение по потоку выполнения,  
мы увидим, что после `NewDirStore` у нас есть ещё вызов `NewUI`, а затем значения, возвращаемые этими функциями, мы передаём в функцию `New`, которая возвращает `*app.App`.

После этого приложение запускается вызовом `a.Run()`.

Как мы уже выяснили, именно там сосредоточена вся координация между слоями.

Описывать весь код построчно я не буду.  
Кому будет интересно, сможет посмотреть детали на GitHub по ссылке в закреплённом комментарии.

На этом всё. Напомню: не забывайте подписываться, если вам хотелось бы ещё выпусков с разбором спецификации.  
Подписка в ТГ и звёздочки на GitHub — тоже дополнительная мотивация.

