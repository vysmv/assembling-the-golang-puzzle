# О массивах и слайсах

## О массивах

Массив в Go — это тип значений, а не указатель на первый элемент (так мной ранее понимались массивы в C из-за того, что массив в выражениях неявно преобразовывался в адрес на первый элемент), и не структура, внутри которой хранится указатель.  
Синтаксическая запись `[N]T` описывает layout значения (форму значения) в памяти.

При обращении `a[2]` компилятор, зная адрес размещения значения `a`, тип `[4]int` (из которого следует размер элемента) и индекс, генерирует адресную арифметику вида:

addr = base_address(a) + 2 × sizeof(int)

> **Важно!**
>
> Важно понимать, что индекса как сущности, существующей в памяти, нет.  
> Индекс — это абстракция языка, логический номер элемента.  
> Реальной величиной является смещение в байтах, которое вычисляется компилятором как `index × sizeof(T)`.

Следовательно, из вышесказанного, синтаксическая запись `*[4]int` в семантике языка Go обозначает указатель на одно значение типа `[4]int`, то есть на массив целиком, а не на его первый элемент. А следовательно, становится доступен полный набор операций, определённых языком для типа `[N]T`. Хотя стоит понимать, что числовое значение адреса `&a` (где `a := [4]int{10, 20, 30, 40}`) совпадает с числовым значением адреса `&a[0]`, но тип указателя и семантика интерпретации этого адреса различны.  
А следовательно, в отношении `&a[0]` недоступны операции, определённые языком для типа `[N]T`, так как это указатель на `int`.

На это можно посмотреть еще и под таким углом: на физическом уровне памяти нет отдельной сущности «массив» — есть только непрерывный диапазон байтов. Массив как целое — это не физический объект, а языковая интерпретация диапазона адресов. То есть это абстрактный слой, определяющий, как компилятор воспринимает адрес.  
По сути, смысл проявляется в том, что в Go, если функция принимает `[4]int`, то это приведёт к копированию всего диапазона.  
А если функция принимает `*[4]int`, то это позволит в её теле читать/писать в любой элемент диапазона массива посредством разыменования.  
НО, если, например, функции передавать `a[0]` или `*a[0]`, то в первом случае тип будет `int`, а во втором случае — указатель на `int`. То есть Go не будет позволять работать с диапазоном, а только с одним элементом, потому что это не массив.
И получать элементы массива посредством адресной арифметики в Go нельзя, без применения специального пакета `unsafe`.

