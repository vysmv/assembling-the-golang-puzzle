# О массивах и слайсах

Прежде чем приступать к этой теме я немного проанализирвал количество и качество контента по этой теме. 
И в общем то уже есть отличные материалы. 
По этому я просто сделаю выкладку в виде резюме из того что сам нашел и проанализировал.
Первым источником стал - Владимир Балун с видео "Ты не все знаешь о массивах и слайсах в Go"
В общем отличный материал. 
Как резюме я сделал для себя такую заметку:

## О массивах
**Массив в Go — это тип значений, а не указатель на первый элемент, как в C, и не структура, внутри которой хранится указатель.
Синтаксическая запись [N]T описывает шаблон значения в памяти.**

Тип `[4]int` сообщает компилятору (на этапе компиляции), что:

* значение занимает `4 × sizeof(int)` байт
* байты расположены непрерывно
* элемент, расположенный по смещению `i × sizeof(int)`, имеет тип `int`

`[4]int` — это чистое значение без ссылочной семантики.

Можно провести аналогию:

* `[4]int` — это чертёж
* переменная `a` — дом, построенный по этому чертежу
* адрес — координаты дома

Дом не хранит координаты внутри себя, но мы можем получить его адрес из факта размещения.

Для доступа к элементу массива указатель внутри массива не нужен.
При обращении `a[2]` компилятор, зная адрес размещения значения `a`, тип `[4]int`, размер элемента и индекс, генерирует адресную арифметику вида:

```
addr = base_address(a) + 2 × sizeof(int)
```

При этом базовый адрес не хранится в массиве — он возникает из факта размещения значения.

**Дополнительно**

Важно понимать, что индекса как сущности, существующей в памяти, нет.
Индекс — это абстракция языка, логический номер элемента.
Реальной величиной является смещение в байтах, которое вычисляется компилятором как `index × sizeof(T)`.

Следовательно из вышесказанного, синтаксическая запись `*[4]int` обозначает указатель на одно значение типа `[4]int`, то есть на массив целиком, а не на его первый элемент.

**Итог:** тип `[N]T` в Go описывает форму и размер значения в памяти, но не содержит и не подразумевает наличие указателя.
Адрес значения возникает из факта его размещения, а доступ к элементам реализуется компилятором через адресную арифметику на основе индекса и известного компилятору типа [N]T.


